; OM File Header - Saved 2023/12/04 14:16:08
; (6.15 :patc (om-make-point 80 168) (om-make-point -8 -8) (om-make-point 1536 713) "" 183 0 "2022/05/02 13:45:26" "2023/11/30 20:27:46")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"C:../../abstractions/chord2pc.omp\"" "#P\"C:../../abstractions/posn-value.omp\"" "#P\"C:../../abstractions/agrupa-seguidos.omp\"" "#P\"C:../../abstractions/sc-name.omp\"" "#P\"C:acordes_alfabeto.omp\""))
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "mercurio1" (quote ((let ((box (om-load-boxcomment "comment 12" (om-make-point 123 32) (quote "avaliar resultado") "" (om-make-point 351 659) nil (om-make-color 0.0 0.069877275 0.99822397) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE 6" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 326 278) (om-make-point 41 48) (load-buffer-textfile (quote ("3" "" "")) (quote textfile) "supersede" "list") nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 6" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 99 464) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 9 11 0 8 9 5 6 8)) :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "chord2pc 4" (quote ("elements" "abstractions" "chord2pc")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 121 398) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 147 346) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 11" (om-make-point 141 46) (quote "alternar entre diferentes soluções") "" (om-make-point 98 298) nil (om-make-color 0.0 0.069877275 0.99822397) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 10" (om-make-point 151 109) (quote "0 a 1 - escala de proximidade$0 = ao acorde$1 = totalmente diferente$indice de diferença") "" (om-make-point 511 444) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 9" (om-make-point 93 41) (quote "fragmento da partitura") "" (om-make-point 512 272) nil (om-make-color 1.0 0.0 0.07060658) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 375 619) (om-make-point 60 42) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE 5" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 204 462) (om-make-point 41 48) (load-buffer-textfile (quote ("2" "" "")) (quote textfile) "supersede" "list") nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 5" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 273 456) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 1 2 7 8 10 10 11 11)) :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE 4" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 452 469) (om-make-point 41 48) (load-buffer-textfile (quote ("0.43" "" "")) (quote textfile) "supersede" "list") nil nil (pairlis (quote (winsize winpos)) (list (om-make-point 335 275) (om-make-point 10 40))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 8" (om-make-point 93 62) (quote "acorde alfabeto transposto") "" (om-make-point 359 466) nil (om-make-color 1.0 0.0 0.07060658) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 7" (om-make-point 88 29) (quote "transposição") "" (om-make-point 183 508) nil (om-make-color 1.0 0.0 0.07060658) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FOURTH" (quote fourth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 326 376) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 269 374) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 212 373) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 4" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 412 253) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 0 11 10 7 1)) :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "chord2pc 3" (quote ("elements" "abstractions" "chord2pc")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 429 169) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 209 250) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 247 274) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 310 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "dist" (om-load-patch-abs1 "dist" (quote ((let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 593 320) nil nil nil (list (let ((box (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 755 469) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 26 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 751 529) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 82 44) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 731 319) (om-make-point 20 29) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number of decimals" "DECIMALS" 0) (om-load-inputfun (quote input-funbox) "divisor" "DIVISOR" 1))) (om-make-point 707 358) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH 2" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 642 356) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD" (quote chord) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (list of midicents)" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "velocities (list of values 0-127)" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (list of values in ms)" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "durations (list of values in ms)" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "MIDI channels (list of values 0-16)" "lchan" (list 1)))) (om-make-point 98 458) (om-make-point 79 98) (let ((thechord (make-instance (quote chord) :lmidic (quote (6200 6300 7300 7400 8700)) :ldur (quote (1000 1000 1000 1000 1000)) :lvel (quote (100 100 100 100 100)) :loffset (quote (0 0 0 0 0)) :lchan (quote (1 1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :midi-player) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 0 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "chord2pc 2" (quote ("elements" "abstractions" "chord2pc")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 233 387) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 3" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 212 473) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 2 3 1 2 3)) :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "chord2pc" (quote ("elements" "abstractions" "chord2pc")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 262 122) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE 2" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 222 210) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos nil :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "all_transp" (om-load-patch-abs1 "all_transp" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 78 309) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil))) (om-make-point 67 188) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "SORT-LIST" (quote sort-list) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 82 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 287 319) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 90 265) (om-make-point 34 30) 12 "12" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 56 295) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM+" (quote om+) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 72 231) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 3 122) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 32 123) (om-make-point 34 30) 11 "11" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 6 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 83 55) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 331 404) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 231 404) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 1 0 0 nil 0) (0 0 1 0 nil 0) (4 0 3 0 nil 0) (2 0 3 1 nil 0) (7 0 4 0 nil 0) (8 0 4 1 nil 0) (5 0 7 0 nil 0) (6 0 7 1 nil 0) (1 1 9 0 nil 0) (1 0 10 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 68 49) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (2 0 1 0 nil 0))) 6.15 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 325 456) nil (list (list (list 1 2 2 3 3) (list 2 3 3 4 4) (list 3 4 4 5 5) (list 4 5 5 6 6) (list 5 6 6 7 7) (list 6 7 7 8 8) (list 7 8 8 9 9) (list 8 9 9 10 10) (list 9 10 10 11 11) (list 0 0 10 11 11) (list 0 0 1 1 11) (list 0 1 1 2 2))) nil "all_transp"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 3" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 331 397) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "set_dist" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 380 317) nil nil nil (list (let ((box (om-load-boxcall (quote abstraction) "set_dist" (om-load-patch-abs1 "set_dist" (quote ((let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 222 290) (om-make-point 38 30) 1.0 "1.0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 250 322) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 239 378) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "set2" 1 (om-make-point 178 18) "" "set2" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "set1" 0 (om-make-point 77 23) "" "set1" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 172 276) (om-make-point 27 30) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 136 256) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number of decimals" "DECIMALS" 0) (om-load-inputfun (quote input-funbox) "divisor" "DIVISOR" 1))) (om-make-point 144 306) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 184 192) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 70 191) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-UNION" (quote x-union) (quote ((om-load-inputfun (quote input-funbox) "a list" "L1?" nil) (om-load-inputfun (quote input-funbox) "a list" "L2?" nil))) (om-make-point 181 102) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-INTERSECT" (quote x-intersect) (quote ((om-load-inputfun (quote input-funbox) "a list" "L1?" nil) (om-load-inputfun (quote input-funbox) "a list" "L2?" nil))) (om-make-point 65 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (7 0 1 1 nil 0) (1 0 2 0 nil 0) (9 0 6 0 nil 0) (8 0 6 1 nil 0) (6 0 7 0 nil 0) (5 0 7 1 nil 0) (10 0 8 0 nil 0) (11 0 9 0 nil 0) (4 0 10 0 nil 0) (3 0 10 1 nil 0) (4 0 11 0 nil 0) (3 0 11 1 nil 0))) 6.15 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" (quote |3-1|)) (om-load-inputfun (quote input-funbox) "" "input 2" (quote |3-1|)))) (om-make-point 115 225) nil (list 1.0) nil "set_dist"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 128 317) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 143 137) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 148 57) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 53 55) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 172 394) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 72 394) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((4 0 0 0 nil 0) (2 0 0 1 nil 0) (0 0 1 0 nil 0) (3 0 2 0 nil 0) (1 1 5 0 nil 0) (1 0 6 0 nil 0))) 1 "set_dist" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 293 303) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "posn-value" (quote ("elements" "abstractions" "posn-value")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 442 395) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 495 366) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 581 428) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 575 358) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "N-CERCLE" (quote n-cercle) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "" "n" 12) (om-load-inputfun (quote input-funbox) "" "puntos" (list 0 5 7)))) (om-make-point 530 475) (om-make-point 87 81) (if (find-class (quote n-cercle) nil) (make-instance (quote n-cercle) :n 12 :puntos (list (list 3 5 6 7 8 9 10 11)) :from-file t)) nil nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 792 611) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 692 611) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((8 1 0 0 nil 0) (20 0 0 1 nil 0) (19 0 0 2 nil 0) (6 0 0 3 nil 0) (4 0 1 0 nil 0) (0 0 2 0 nil 0) (7 0 6 0 nil 0) (5 0 6 1 nil 0) (20 0 7 0 nil 0) (15 0 7 1 nil 0) (1 0 8 1 nil 0) (8 1 9 0 nil 0) (9 0 10 2 nil 0) (3 0 11 0 nil 0) (11 0 12 2 nil 0) (14 0 13 0 nil 0) (10 2 14 0 nil 0) (16 0 15 0 nil 0) (13 0 15 1 nil 0) (12 2 16 0 nil 0) (15 0 17 0 nil 0) (18 0 17 1 nil 0) (20 0 19 0 nil 0) (13 0 19 1 nil 0) (17 0 20 0 nil 0) (19 0 21 2 nil 0) (2 1 22 0 nil 0) (2 0 23 0 nil 0))) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH 2" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 392 371) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FIRST-N" (quote first-n) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil) (om-load-inputfun (quote input-funbox) "number of elements" "N" 0))) (om-make-point 313 522) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 311 455) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 256 337) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" (quote lenght)) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 296 389) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "agrupa-seguidos" (quote ("elements" "abstractions" "agrupa-seguidos")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 147 485) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 131 406) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 601 412) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 5 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 192 282) (om-make-point 29 30) (quote <) "<" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "posn-value" (quote ("elements" "abstractions" "posn-value")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 150 312) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "vect_dist" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil))) (om-make-point 104 225) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 257 171) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "vect_dist 2" (om-load-patch-abs1 "vect_dist" (quote ((let ((box (om-load-boxcomment "comment" (om-make-point 235 89) (quote "vector intervalar distance$$intervalos diferentes / $número de intervalos") "" (om-make-point 307 84) nil (om-make-color 1.0 0.0 0.19541854) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 165 3) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 78 5) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 223 478) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 172 408) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number of decimals" "DECIMALS" 2) (om-load-inputfun (quote input-funbox) "divisor" "DIVISOR" 1))) (om-make-point 211 400) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" nil) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 245 182) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 4" (quote t) (quote nil) (om-make-point 211 233) (om-make-point 29 30) (quote +) "+" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPLY 2" (quote apply) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "ARG" "ARG" nil))) (om-make-point 254 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 169 71) (om-make-point 46 30) (quote |5-10|) "5-10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PC-SET 2" (quote pc-set) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :vector) (list (list "integer" (quote :integer)) (list "vector" (quote :vector)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FN-NAME" (quote |6-Z10|)))) (om-make-point 145 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 74 74) (om-make-point 39 30) (quote |7-1|) "7-1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "PC-SET" (quote pc-set) (quote ((om-load-inputfunmenu1 (quote input-funmenu) "" "TYPE" (quote :vector) (list (list "integer" (quote :integer)) (list "vector" (quote :vector)) (list "pitch" (quote :pitch)))) (om-load-inputfun (quote input-funbox) "" "FN-NAME" (quote |6-Z10|)))) (om-make-point 50 104) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 50 295) (om-make-point 29 30) (quote +) "+" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPLY" (quote apply) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "ARG" "ARG" nil))) (om-make-point 93 329) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ABS" (quote om-abs) (quote ((om-load-inputfun (quote input-funbox) "number or tree" "SELF" 1))) (om-make-point 88 250) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 103 198) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 3 0 nil 0) (14 0 4 0 nil 0) (8 0 4 1 nil 0) (4 0 5 0 nil 0) (12 0 6 0 nil 0) (10 0 6 1 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (1 0 10 1 nil 0) (2 0 12 1 nil 0) (13 0 14 0 nil 0) (15 0 14 1 nil 0) (16 0 15 0 nil 0) (12 0 16 0 nil 0) (10 0 16 1 nil 0))) 6.15 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 58 228) nil (list 0.33) nil "vect_dist"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 96 122) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 99 46) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 28 45) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((1 0 0 0 nil 0) (4 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (0 1 5 0 nil 0) (0 0 6 0 nil 0))) 1 "vect_dist" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "sc-name" (quote ("elements" "abstractions" "sc-name")) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 34 143) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "acordes_alfabeto" (quote ("elements" "Galaxias" "Cartas" "acordes_alfabeto")) (quote nil) (om-make-point 151 137) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (9 0 0 1 nil 0) (14 0 1 0 nil 0) (2 0 1 1 nil 0) (11 0 2 0 nil 0) (3 0 2 1 nil 0) (5 0 3 0 nil 0) (4 0 5 0 nil 0) (6 0 5 1 nil 0) (7 0 6 0 nil 0) (12 0 7 0 nil 0) (11 0 7 1 nil 0) (0 0 8 0 nil 0) (12 0 11 0 nil 0) (10 0 11 1 nil 0) (13 0 12 0 nil 0) (14 1 12 1 nil 0) (9 0 13 0 nil 0))) 6.15 nil "" (om-make-point 200 200) (om-make-point 500 340)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 236 160) (om-make-point 61 67) (list (list (list (list 6700 7200 7300 7600 7700 7800) 6 (list 0 1 6 7 10 11) 0.17) (list (list 6300 6600 7300 7400 7900 8800) 6 (list 0 1 7 8 9 10) 0.43) (list (list 5700 5900 6000 6800 6900 7700 7800 8000) 2 (list 1 2 7 8 10 10 11 11) 0.43))) nil "dist"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 179 85) (quote "lista interna dos fragmentos da musica - gestos$0 é a primeira ..") "" (om-make-point 58 62) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 5" (om-make-point 112 59) (quote "selecionar fragmento da partitura") "" (om-make-point 344 81) nil (om-make-color 1.0 0.0 0.07060658) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 288 94) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 319 127) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "TEXTFILE" (quote textfile) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "input data or text" "exp-list" nil) (om-load-inputfunmenu1 (quote input-funmenu) "append or supersede" "ed-mode" "supersede" (list (list "append" "append") (list "supersede" "supersede"))) (om-load-inputfunmenu1 (quote input-funmenu) "eval interpretation mode" "eval-mode" "list" (list (list "text" "text") (list "data list" "data") (list "list" "list") (list "value" "value"))))) (om-make-point 304 23) (om-make-point 70 50) (load-buffer-textfile (quote ("(0 11 10 2)" "(0 11 10 7 1)" "(0 11 10 2)" "(8 11 5 4 3 6 10 7 9)" "(2 8 7 0 1 9 3 2)" "(5 11 0 2 4 11 9 7 5 4)" "(4 9 11 0 2 7 9 11 0 5)" "(2 7 9 11 0 9 11 0 2 7)" "(0 5 7 9 11 11 0 2 4 9)" "(11 4 5 7 9 0 2 4 5 11)" "(9 2 4 5 7 2 4 5 7 0)" "(7 0 2 4 5 4 5 7 9 2)" "(11 0 2 4 5 5 7 9 11 4)" "(4 9 11 0 2 7 9 11 0 5)" "(2 7 9 11 0 9 11 0 2 7)" "(0 5 7 9 11 11 0 2 4 9)" "(3 4 5 11 6)" "(10 8 7 9 6 5 7 5)" "(8 7 9 11 1 0 2 4 6 5 7 9)" "(8 7 9 11 1 0 2 4 6 5 7 9 10)" "(2 1 3 4 7 6 8 10 0 1 3 4)" "(5 6 8 9 10 11 0 2 3 6 4 5 7)" "(9 10 0 2 4 3 5 7 11 10 0 2)" "(3 5 4 2)" "(5 4 3 7)" "(5 4 3 0 6)" "(9 8)" "(9 8 7 6)" "(9 8 7 6 5)" "(9 8 7 6 5 4)" "(9 3 4 5 11 0 2 4 5 7)" "(9 10)" "(9 8)" "(9 8 2 3)" "(8 5 9 4)" "(8 3 9 2)" "(9 11 0 2 3)" "(8 9 3 2)" "(8 4 9 5)" "(8 1 9 0)" "(8 9 2 3)" "(0 11 10 6 11 9 5 4)" "(2 9 8 3 9)" "(5 4 3 6 2)" "(5 11 10)" "(2 7 6 8)" "(7 2 1)" "(9 4 3)" "(8 1 6 5 2 4)" "(4 9 2 9 7 8)" "(2 7 0 9 11 10)" "(10 3 8 0 2 1)" "(5 11 4 5 6 7)" "(1 6 11 9 6)" "(7 0 5 2 4 3)" "(4 9 2 5 7 6)" "(2 7 0 7 9 8)" "(1 6 11 0 10 9)" "(9 8 1 6 10 11)" "(2 7 0 9 10 11) " "(5 10 3 9 10 11)" "(9 4 7 8 9 10 11)" "(3 2 1 0 4 5 6)" "(1 2 3 4 5 6)" "(5 4 3 7 8)" "(7 6 9 3 5)" "(0 1 2)" "(0 1 2 8)" "(3 0 2 9 11)" "(3 0 2 9 11 7 4 5)" "(2 6 9 0 3 6 10 2)" "(10 3 9)" "" "" "" "")) (quote textfile) "supersede" "list") "x" nil (pairlis (quote (winpos winsize)) (list (om-make-point 10 40) (om-make-point 335 275))) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((21 0 1 1 nil 0) (3 0 2 2 nil 0) (4 0 3 0 nil 0) (20 0 4 0 nil 0) (9 0 8 0 nil 0) (10 0 8 1 nil 0) (11 0 8 2 nil 0) (17 0 8 3 nil 0) (2 0 8 4 nil 0) (1 0 8 5 nil 0) (16 0 9 1 nil 0) (15 0 10 2 nil 0) (14 0 11 1 nil 0) (20 0 14 0 nil 0) (20 0 15 0 nil 0) (20 0 16 0 nil 0) (18 0 17 2 nil 0) (26 0 18 0 nil 0) (19 0 20 0 nil 0) (22 0 20 1 nil 0) (22 0 21 0 nil 0) (26 0 22 0 nil 0) (25 0 26 0 nil 0) (27 1 26 1 nil 0))) nil 6.15))
